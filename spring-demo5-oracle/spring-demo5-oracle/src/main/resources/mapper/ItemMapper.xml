<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="kr.co.itwillbs.oracle.item.mapper.ItemMapper">
	<!-- 상품 전체 목록 조회 - SELECT -->
	<!-- 
	주의! 엔티티 클래스의 필드명(Camel-case)과 데이터베이스 컬럼명(Snake-case)이 서로 일치하지 않을 경우
	데이터 조회 시 조회된 데이터가 엔티티 객체에 바인딩되지 않으므로 대책이 필요하다!
	1) properties 파일에 "mybatis.configuration.map-underscore-to-camel-case=true" 설정 추가  
	   => 조회된 컬럼명에 대한 Snake-case 형태를 Camel-case 형태로 자동 변환
	2) resultMap 태그를 활용하여 조회된 데이터를 별도의 형태로 처리하도록 설정 
	   => 기본적인 이름 변경 기능 외에 별도로 기능 추가(ex. TypeHandler 등록)가 가능
	-->
	<!-- 조회 결과를 List<Item> 객체에 저장해야함 => resultType 은 단일 레코드 저장하는 객체 타입 지정 -->
<!-- 	<select id="findAllItems" resultType="kr.co.itwillbs.oracle.item.entity.Item"> -->
	<!-- type alias 기능을 활용하여 객체 타입 축약 => properties 파일이나 별도의 설정 파일에 alias 설정 추가 필요 -->
<!-- 	<select id="findAllItems" resultType="Item"> -->
<!-- 		SELECT id, item_nm, item_detail, price, stock_qty, category, sell_status, reg_time, update_time -->
<!-- 		FROM items -->
<!-- 	</select> -->

	<!-- resultMap 활용하여 결과 데이터를 관리할 별도의 형태를 지정 -->
	<!-- <resultMap type="처리할 데이터의 클래스 타입(resultType 속성에서 사용하는 타입)" id="resultMap 이름(각 태그에서 불러올 이름)"> -->
	<resultMap type="Item" id="itemResultMap">
		<!-- 실제 조회된 데이터에 대한 바인딩을 직접 지정하여 처리 -->
		<!-- PK 컬럼(@id)만 <id> 태그로 작성하고, 나머지 컬럼은 <result> 태그로 작성 -->
		<!-- property 속성은 엔티티 클래스의 필드명, column 속성은 데이터베이스 테이블 필드명(컬럼명)을 지정 -->
		<!-- typeHandler 속성은 타입 핸들러가 있을 경우 핸들러 클래스 지정 -->
		<id property="id" column="id" />
		<result property="itemNm" column="item_nm" />
		<result property="itemDetail" column="item_detail" />
		<result property="price" column="price" />
		<result property="stockQty" column="stock_qty" />
		<result property="category" column="category" />
		<result property="sellStatus" column="sell_status" />
		<result property="regTime" column="reg_time" />
		<result property="updateTime" column="update_time" />
	</resultMap>
	<!-- <select> 태그에서 resultType 대신 resultMap 속성을 사용하여 별도로 지정한 타입(<resultMap> 태그의 id 속성값) 사용하도록 설정 -->
	<select id="findAllItems" resultMap="itemResultMap">
		SELECT id, item_nm, item_detail, price, stock_qty, category, sell_status, reg_time, update_time
		FROM items
	</select>
	
	<!-- ============================================================================================== -->
	<!-- 상품정보 수정 - UPDATE -->
	<!-- UPDATE 테이블명 SET ${컬럼명} = #{데이터} WHERE 컬럼명 = #{찾을값} -->
	<!-- => 컬럼명의 경우 데이터타입에 따라 따옴표가 붙을 필요가 없으므로 #{} 대신 ${} 사용 -->
	<!-- => 주의! ${} 사용 시 SQL Injection(SQL 삽입) 공격에 노출될 수 있다! 따라서, 해당 데이터에 대한 판별을 사전에 수행해야함! -->
	<update id="updateItem">
		UPDATE items
		SET ${name} = #{value}
		WHERE id = #{id}
	</update>
	
	<!-- ============================================================================================== -->
	<!-- 검색 기능을 활용한 상품 목록 조회 - SELECT -->
	<select id="findItemsBySearchParams" resultMap="itemResultMap">
		SELECT *
		FROM items
		WHERE 1 = 1  -- 다른 조건(AND)이 없을 경우 WHERE 절을 무효화시키기 위해 결과값이 true 가 되는 연산을 아무거나 지정 가능
		<!-- 검색할 조건(상품명 or 가격)에 따라 WHERE 절 조건을 추가 -->
		<if test="itemNm != null and itemNm != ''">
			AND item_nm LIKE '%' || #{itemNm} || '%'
		</if>
		<if test="minPrice != null">
			AND price >= #{minPrice}
		</if>
		<!-- price <= maxPrice 조건 설정해야할 경우 < 기호가 태그 시작기호로 인식되므로 오류 발생함(price &lt;= maxPrice 형태로 작성 => 가독성 나쁨) -->
		<!-- 이 때, <, & 등의 특수기호(XML 에서 이스케이프 문자로 사용해야하는 대상)를 표기하기 위해 CDATA 사용 -->
		<!-- 주의! if 등의 태그 바깥에서 사용 시 if 등의 태그가 동작하지 않으므로 태그 내에서 문장 작성 시 활용 -->
		<if test="maxPrice != null">
			<![CDATA[
			AND price <= #{maxPrice}
			]]>
		</if>
	</select>
	
</mapper>





























