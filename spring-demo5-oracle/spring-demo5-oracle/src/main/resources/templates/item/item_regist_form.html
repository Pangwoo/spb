<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
	xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
	layout:decorate="~{layouts/layout}">
<head>
	<title>Insert title here</title>
	<!-- 개별페이지 전용 스타일시트 영역 -->
	<th:block layout:fragment="style">
		<link rel="stylesheet" th:href="@{/css/main.css}" />
		<style>
			#imgPreviewArea {
				display: flex;
				flex-wrap: wrap;
				gap: 10px;
				width: 100%;
			}
			
			.div-img-preview {
				display: flex;
				flex-direction: column;
				align-items: center;
				border: 1px solid #ccc;
				padding: 10px;
			}
			
			.img-preview {
				width: 100px;
				height: 100px;
				display: block;
			}
		</style>
	</th:block>
</head>
<body>
	<th:block layout:fragment="content">
		<h3>상품 등록</h3>
		<div id="registForm">
			<!-- 컨트롤러에서 DTO 객체를 전달받았을 경우 -->
			<!-- form 태그에서 th:object 속성을 사용하여 전달받은 DTO 객체를 선택하면 -->
			<!-- 해당 form 내에서 name 속성 지정 생략도 가능하고, DTO 객체의 값들을 폼에서 사용도 가능함(Validation check 등) -->
<!-- 			<form th:action="@{/items}" th:object="${item}" method="post"> -->
			<!-- 파일 업로드를 위한 enctype 설정 -->
			<form th:action="@{/items}" th:object="${item}" method="post" enctype="multipart/form-data">
				<table border="1">
					<tr>
						<th>상품명</th>
						<td>
							<!-- 입력요소 태그에 th:field 속성을 사용하여 해당 입력 요소에 DTO 객체의 필드를 바인딩(name 속성 생략 가능) -->
							<input type="text" th:field="*{itemNm}"> <!-- name 속성값이 자동으로 itemNm 으로 설정됨 -->
							<!-- Validation 체크 실패로 인해 다시 입력 페이지로 돌아왔을 때 실패한 항목에 대한 처리(오류 메세지 표시) -->
							<!-- th:if 활용하여 에러 발생 여부 체크하고, th:error 활용하여 에러 발생에 대한 메세지 출력을 위해 필드 지정 -->
							<!-- 에러 발생 여부는 타임리프 내장객체 fields 객체의 hasError() 메서드 활용(파라미터로 필드명 전달) -->
							<!-- 기본 문법 : th:if="${#fields.hasError('필드명')} th:errors="*{필드명}" -->
							<div th:if="${#fields.hasErrors('itemNm')}" th:errors="*{itemNm}"></div>
						</td>
					</tr>
					<tr>
						<th>가격</th>
						<td>
							<input type="number" th:field="*{price}"> <!-- name 속성값이 자동으로 price 로 설정됨 -->
							<div th:if="${#fields.hasErrors('price')}" th:errors="*{price}"></div>
						</td> 
					</tr>
					<tr>
						<th>재고수량</th>
						<td>
							<input type="number" th:field="*{stockQty}"> <!-- name 속성값이 자동으로 stockQty 로 설정됨 -->
							<div th:if="${#fields.hasErrors('stockQty')}" th:errors="*{stockQty}"></div>
						</td> 
					</tr>
					<tr>
						<th>카테고리</th>
						<td>
							<select th:field="*{category}">
								<option value="">카테고리 선택</option>
								<!-- ItemCategory 의 모든 값을 배열로 전달했으므로 해당 배열(categories)을 반복하여 option 태그 생성 -->
								<!-- 실제 전달될 값(th:value 속성)은 반복되는 enum 상수값을 그대로 사용 -->
								<!-- 화면에 표시될 값(th:text 속성)은 각 상수에 할당된 문자열을 사용하기 위해 label 필드에 접근(enum 에서 설정 추가 필요) -->
<!-- 								<option th:each="cat : ${categories}" -->
								<!-- ItemDTO 객체 내에 ItemCategory enum 값들을 함께 저장했으므로 ${} 대신 *{} 사용 -->
<!-- 								<option th:each="cat : *{categories}" -->
								<!-- 타임리프에서 자바 클래스 직접 참조하는 방법(enum 타입도 가능) : ${T(패키지명.클래스명).메서드명()} -->
								<option th:each="cat : ${T(kr.co.itwillbs.oracle.commons.constant.ItemCategory).values()}"
										th:value="${cat}"
										th:text="${cat.label}"></option>
							</select>
							<div th:if="${#fields.hasErrors('category')}" th:errors="*{category}"></div>
						</td>
					</tr>
					<tr>
						<th>판매상태</th>
						<td>
							<select th:field="*{sellStatus}">
								<option value="">판매상태 선택</option>
<!-- 								<option th:each="status : *{sellStatuses}" -->
								<option th:each="status : ${T(kr.co.itwillbs.oracle.commons.constant.ItemSellStatus).values()}"
										th:value="${status}"
										th:text="${status.label}"></option>
							</select>
							<div th:if="${#fields.hasErrors('sellStatus')}" th:errors="*{sellStatus}"></div>
						</td>
					</tr>
					<tr>
						<th>상세설명</th>
						<td>
							<!-- 텍스트에어리어도 동일한 방식으로 th:field 속성 적용 가능 -->
							<textarea th:field="*{itemDetail}" rows="4" cols="20"></textarea>
							<div th:if="${#fields.hasErrors('itemDetail')}" th:errors="*{itemDetail}"></div>
						</td>
					</tr>
					<tr>
						<th>상품이미지<br>(최대5개)</th>
						<td>
							<input type="file" id="custom-file-input" name="itemImgFiles" accept="image/*" multiple>
							<div id="imgPreviewArea"></div>
						</td>
					</tr>
					<tr>
						<td colspan="2"><input type="submit" value="등록"></td>
					</tr>
				</table>
			</form>
		</div>
	</th:block>
	
	<!-- 레이아웃 내의 script 프래그먼트 영역에 추가될 스크립트 -->
	<th:block layout:fragment="script">
		<script th:src="@{/js/main.js}"></script>
		<script>
			$(function() {
				// 상품 이미지 선택하지 않고 요청했을 때 서버로부터 전달받은 오류메세지가 있을 경우 출력
// 				const msg = "${errorMessage}";
				// => 주의! 타임리프와 jQuery 함께 사용하는 페이지에서 ${} 활용하여 서버로부터 전달받은 속성에 접근하려 할 때
				//    정상적인 파싱이 수행되지 않고 ${} 기호가 단순 문자열로 취급되어 그대로 출력됨
				// 타임리프 객체 접근 문법 앞 뒤로 [[ 기호와 ]] 기호로 감싸면 정상적인 처리가 가능하다!
				const errorMessage = "[[${errorMessage}]]";
				if(errorMessage && errorMessage.trim() !== "") {
					alert(errorMessage);
				}
				
				
				// ======================================================================================
				// 이미지 파일 선택 시 미리보기 생성
				// => 파일 입력 요소 change 이벤트 핸들링
				// => 파일 요소 이벤트 객체 가져와서 선택한 파일에 접근
				$("#custom-file-input").change(function(event) { // 파라미터로 발생한 이벤트 객체 전달받기
					// 파일 선택 요소의 선택된 파일 목록 가져오기
					const files = event.target.files;
// 					console.log(files);
					
					// ------------------------------------------------------------------------------------------------------
					// 이미지 파일만 필터링(다른 형식의 파일까지 선택됐을 경우 미리보기 대상을 이미지 파일로 한정하기 위함)
					let imageFiles = Array.from(files).filter(file => file.type.startsWith("image/"));
					console.log(imageFiles);
					
					// 선택된 파일 갯수 제한
					// => x개를 초과하면 경고 출력 후 x개 파일을 제외한 나머지 버리기
					const imageCountLimit = 5;
					if(imageFiles.length > imageCountLimit) { // 이미지 파일 갯수 5개 제한
						alert("최대 " + imageCountLimit + " 개의 이미지 파일만 업로드 가능합니다!");
						
						imageFiles = imageFiles.slice(0, imageCountLimit); // 배열 내의 파일을 0번부터 지정된 갯수만큼 자르기(나머지 버림)
// 						debugger;
					}
					// ------------------------------------------------------------------------------------------------------
					
					// 기존 미리보기 영역 초기화
					$("#imgPreviewArea").html("");
					
					// 기존 파일 선택 영역을 교체할 새로운 파일 목록 객체로 변경하기 위해 DataTrasnfer 객체 생성
					let newFileList = new DataTransfer();
					
					// 이미지 파일 갯수만큼 반복(익명함수 파라미터로 파일 요소 인덱스 및 파일 객체 전달받기)
					$.each(imageFiles, function(index, file) {
						// 현재 파일을 새로운 DataTransfer 객체에 추가
						newFileList.items.add(file);
						
						// --------------------------------
						// FileReader 객체 생성 후 파일 읽어와서 미리보기 영역에 표시
						let reader = new FileReader();
						
						// 파일을 읽어오기 전에 먼저 FileReader 객체의 load 이벤트 핸들링
						reader.onload = function(e) {
// 							console.log(e.target.result); // Base64 인코딩 된 파일 정보 출력

							// 미리보기 요소 생성 후 미리보기 영역에 추가
							let imgPreview = $(`<div class="div-img-preview">`)
								.append(`<img src="${e.target.result}" alt="미리보기" class="img-preview">`);
								
							// 미리보기 영역에 미리보기 이미지 추가
							$("#imgPreviewArea").append(imgPreview);
						}
						
						// 파일 읽어오기
						// => 이미지 파일 등을 Base64 인코딩된 데이터 형식으로 읽어오기 위해 readAsDataURL() 메서드 활용
						//    (미리보기, AJAX 활용한 파일 업로드 등에 활용 가능)
						reader.readAsDataURL(file);
						
					});
					
					// 파일 선택 요소의 files 속성을 새로운 FileList 객체로 업데이트
					console.log($("#custom-file-input"));
					$("#custom-file-input")[0].files = newFileList.files;
					
				});
			});
		</script>
	</th:block>
</body>
</html>
























